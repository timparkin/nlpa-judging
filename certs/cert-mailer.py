
# Import smtplib library to send email in python.
import smtplib
# Import MIMEText, MIMEImage and MIMEMultipart module.
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
from email.utils import formataddr

import math
import os
import pandas as pd
import sys
import glob
from pathlib import Path
import yaml
import base64
import mailtrap as mt
from mailtrap import Mail, Address, MailtrapClient, Attachment, Disposition
from jinja2 import Template


TEST = True


def estimate_attachment_size(content: bytes) -> int:
    """
    Estimate the size of an attachment when base64-encoded.
    Base64 encoding expands data size by ~33%.
    """
    return len(base64.b64encode(content))


def check_email_size(subject: str, text: str, attachments: list[Attachment]) -> int:
    """
    Estimate total email size: body text + encoded attachments.
    """
    size = len(subject.encode("utf-8")) + len(text.encode("utf-8"))

    for att in attachments:
        size += estimate_attachment_size(att.content)

    return size

# Files Needed
#  - cert-email-template.html
#  - cert-email-template.txt
#  - certs.csv (generated by build_certs) <!---- read this in from the config,yaml file and also read in the location of the files (currently hard coded)





def send_email(user_id, data, certs, cert_folder, year, photo_certs_emails):


    # Define the source and target email address.



    strFrom = formataddr(('Natural Landscape Photography Awards', 'info@naturallandscapeawards.com'))


    if TEST:
        strTo = 'info@timparkin.co.uk'
        name = data['email']
    else:
        strTo =data['email']
        name = data['name']
    # strTo = 'info@timparkin.co.uk'
    # strTo = 'info@naturallandscapeawards.com'




    mt_subject = 'Photo Certificates for {} from the Natural Landscape Photography Awards'.format(name)

    mt_sender = mt.Address(email='info@naturallandscapeawards.com', name='Natural Landscape Photography Awards')
    mt_to = [mt.Address(email=strTo, name=name)]





    # Create a MIMEText object to contains the email Html content. There is also an image in the Html content. The image cid is image1.
    html_email = Template(open('certs/cert-email-template.html').read())

    cert_items = []
    max_stage = 0

    highest_stage = 0
    for cert in certs:
        stage_text = cert['stage_text']
        type = cert['type']
        if type == 'project':
            stage_max = 5
        else:
            stage_max = 6
        stage_number = int(stage_text[0])
        stage_name = stage_text[2:].split('(')[0].strip()
        subheader = cert['subheader']
        category = subheader.split(',')[0]

        if ',' in subheader:
            award = subheader.split(',')[1].strip()
            prize = ' ({})'.format(award)
        else:
            award = None
            prize = ''
        if award =="Winner":
            stage_number = 12
        elif award == "Runner Up":
            stage_number = 11
        elif award == "Third Place":
            stage_number = 10
        elif award == "Fourth Place":
            stage_number = 9
        elif award == "Fifth Place":
            stage_number = 8
        elif award == "Highly Commended":
            stage_number = 7


        if type == "project":
            if 'project-2' in cert['target_filename']:
                title = 'Project "{}" '.format(str(cert['project_2'])[:90])
            elif 'project-1' in cert['target_filename']:
                title = 'Project "{}" '.format(str(cert['project_1'])[:90])
            category = f'{title}'

        max_stage = max(stage_number, max_stage)
        if stage_number > 6:
                cert_text = f'<strong>{category}, {award}</strong>'
        else:
            cert_text = f'<strong>{category}</strong> <em>{stage_name}</em>'

        highest_stage = max(highest_stage, stage_number)
        cert_items.append( (stage_number/stage_max, '<li>{}</li>'.format(cert_text) ) )

    cert_items.sort(key=lambda tup: tup[0], reverse=True)

    header_text_1 = """
Natural Landscape Photography Awards, {}
""".format(year)

    header_text_2 = """
Award Certificates for {}
""".format(name)

    intro_text_1 = """
We were blown away by the number and quality of entries from all over the world. 11,023 photographs were submitted to the competition by 1,134 photographers from 64 countries<br><br>
We are incredibly grateful to each and every one of you who entered. Don't forget all of your certificates are attached to this email!
    """


    optional_text = """
Like last year, we have created a certificate for every one of your entries which you can find attached to this email. We’ve written a guide to how the judging took place which you can find <a href="https://naturallandscapeawards.com/judging-process/">here</a> which also includes a key to the certificates. If you have any questions, please feel free to contact us. You can see the rest of the winners on our awards page <a href="https://naturallandscapeawards.com/2025-competition-results-gallery">results page</a>.<br><br>"""



    outro_text = """
Judging is always subjective and what may not work for one judge may be engaging for another. In our final judging, there were few images that all the judges unanimously agreed on. If you’re interested in learning more about what worked for our judges and what didn’t, how post-processing affects the judge’s responses, what aspects of composition are seen as important and more, we’ll be having free sessions discussing these before next years competition launches.<br><br>

<div style="text-align: center;"><a href="https://naturallandscapeawards.com/product/natural-landscape-volume-five-2025/"><img src="cid:book" width="600" style="display:block;"  /></a></div><br>

To commemorate the success of our fifth year of running the awards, we will create our fifth compendium, continuing on our tradition of creating the finest compilations of landscape and nature photography available. This book will be a 220-page large format fine art book containing the work of over 140 artists from all over the world. We have also commissioned several essays which are included in the book, relating to the ethos of our competition – the eyewitness tradition of photography and the idea of representing the world around us with truth and honesty. We also include a PDF with a full page story about every photograph in the book. We are once again printing this year's book through Johnsons Book Printing in the UK so that we can physically be on-site to manage and expedite the process.<br><br>The book will be <strong>printed in January next year and we hope to have it in your hands by March </strong>if all goes smoothly (which it never seems to do in book publishing, cross fingers this time)!<br><br>

You can pre-order the book <a href="https://naturallandscapeawards.com/product/natural-landscape-volume-five-2025/">here</a>. Here's a preview of the cover!<br><br>


We’re also excited to share a special offer just for NLPA entrants: 20% off a Nature Photographer’s Network (NPN) membership. Simply use the code <strong>NLPA20</strong> at checkout.<br><br>

NPN is a community built by and for nature photographers. It’s designed to help you grow, connect, and be inspired:<br>

<ul>
<li>Thoughtful Feedback – Receive constructive critiques from peers and professionals.</li>
<li>Exclusive Articles & Resources – Access essays and tutorials from leading voices in nature photography.</li>
<li>Supportive Community – Connect with photographers who share your passion for wild places and authentic imagery.</li>
<li>Inspiration & Growth – Explore new ideas through themed challenges and discussions.</li>
</ul>

Unlike social media’s quick likes and surface-level engagement, NPN fosters genuine connection and meaningful growth in your photography journey.<br><br>

We hope this helps you continue refining your vision and finding inspiration in the company of others who share your love for the natural world.<br><br>

Join NPN with 20% Off → <a href="https://community.naturephotographers.network/?utm_source=naturallandscapeawards.com">community.naturephotographers.network</a>.<br><br>

Sincerely, <br><br>
Matt, Tim, Alex, and Rajesh<br><br>

p.s. Our system occasionally misses a few images, no software is perfect and we can't check all >12,000 generated jpgs. Please let us know if you think you're missing anything. 
"""

    cert_items_text = Template("""
    <div><br><br>
      <h3>Certificates</h3>
        <div style="text-align: left;"><span style="font-family:roboto,helvetica neue,helvetica,arial,sans-serif"><span style="font-size:14px">Here's a list of the certificates for your images. Each of these is shown in the contact sheet below and a jpg is also attached to this email.</div>
      <ul id="certs" style="padding: 0px 18px 9px 30px; list-style-type: none; font-size: 14px; font-family: Roboto, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-style: normal; font-weight: normal; line-height: 125%; text-align: left;">
        {{ cert_items }}
        </ul>
    </div>
    <div style="text-align: center;"><img  alt="Certificates" style="display:block;" width="600" src="cid:contacts"></div>
    """).render({'cert_items':'\n'.join( [i[1] for i in cert_items] )})








    tdata =  {
        'name': name,
        'email': strTo,
        'user_id': data['id'],
        'subject': mt_subject,
        'cert_items': cert_items_text,
        'header_text_1': header_text_1,
        'header_text_2': header_text_2,
        'intro_text_1': intro_text_1,
        'optional_text': optional_text,
        'outro_text': outro_text,
        }



    msgText = MIMEText(html_email.render(**tdata), 'html')

    mt_html = html_email.render(**tdata)

    with open('{}/cert-{}.html'.format(photo_certs_emails,data['id']), 'w') as file:
        file.write(html_email.render(**tdata))



    tdata =  {
        'name': data['name'],
        'email': data['email'],
        'user_id': data['id'],
        'subject': mt_subject,
        'cert_items': cert_items_text,
        'header_text_1': header_text_1.replace('<br><br>','').strip(),
        'header_text_2': header_text_2.replace('<br><br>','').strip(),
        'intro_text_1': intro_text_1.replace('<br><br>','').strip(),
        'optional_text': optional_text.replace('<br><br>','').strip(),
        'outro_text': outro_text.replace('<br><br>','').strip(),
        }

    # Create a MIMEText object, this object contains the plain text content.
    txt_email = open('certs/cert-email-template.txt').read()
    txt_email = Template(txt_email)

    msgText = MIMEText(txt_email.render(**tdata))
    mt_text = txt_email.render(**tdata)
    # Attach the MIMEText object to the msgAlternative object.




    #################################################
    #
    #     Open a file object to read the image file, the image file is located in the file path it provide.
    target_filename = "certs/nlpa-logo-800.png"
    attach1 =  mt.Attachment(
            content=base64.b64encode(Path(target_filename).read_bytes()),
            filename=target_filename,
            disposition=mt.Disposition.INLINE,
            mimetype="image/png",
            content_id="logo",
        )

    #################################################
    #
    #     Open a file object to read the image file, the image file is located in the file path it provide.
    target_filename = "certs/volume-5-cover.jpg"
    attach2 =  mt.Attachment(
            content=base64.b64encode(Path(target_filename).read_bytes()),
            filename=target_filename,
            disposition=mt.Disposition.INLINE,
            mimetype="image/png",
            content_id="book",
        )

    #################################################
    #
    #    Open a file object to read the image file, the image file is located in the file path it provide.
    target_filename = "{}/{}/contacts.jpg".format(cert_folder,user_id)

    attach3 =  mt.Attachment(
            content=base64.b64encode(Path(target_filename).read_bytes()),
            filename=target_filename,
            disposition=mt.Disposition.INLINE,
            mimetype="image/png",
            content_id="contacts",
        )



    attachments = [attach1,attach2, attach3]
    for n, cert_data in enumerate(certs):

        fp = cert_data['target_filename']
        fn = fp.split('/')[-1]

        file_content = Path(fp).read_bytes()
        encoded_content = base64.b64encode(file_content)

        attachments.append( Attachment(
            content=encoded_content,  # The base64 encoded content of the file
            filename=fn,  # The name of the file as it should appear in the email
            disposition=Disposition.ATTACHMENT,  # Indicates that the file is an attachment
            mimetype="application/pdf",  # The MIME type of the file
        ) )




    #########################################
    # Create a Mail object with an attachment
    #########################################
    mail = Mail(
        sender=mt_sender,
        to=mt_to,
        subject=mt_subject,
        text=mt_text,
        html=mt_html,
        # Define the attachment
        attachments=attachments,
    )
    #########################################
    #########################################
    #########################################
    #########################################

    client = mt.MailtrapClient(token="e46f57d10b2116dc442361d475500516")
    client.send(mail)

    #print(f"{int(data['id'])},")



config = 'config.yaml'
with open(config) as f:
     yaml_data = yaml.safe_load(f)

yaml_args = yaml_data['args']

certs_csv = yaml_args['certs_csv']
full_csv = yaml_args['fullcsv']
cert_folder = yaml_args['cert_folder']
year = yaml_args['year']
photo_certs_emails = yaml_args['photo_certs_emails']
Path(photo_certs_emails).mkdir(parents=True, exist_ok=True)




df = pd.read_csv(full_csv)
entry_by_user_id = {}
for i in range(len(df)):
    r = df.loc[i]
    id = r['id']
    if math.isnan(id):
        continue
    entry_id = r['entry_id']
    if id in entry_by_user_id:
        entry_by_user_id[id].append(r)
    else:
        entry_by_user_id[id] = [r]


df = pd.read_csv(certs_csv)


certs_by_id = {}

# this is to skip onees alreeaedy sent. id's are produced by the code as general output
# Might be worth storing ID's in a file instead

# with open('missing_mandrill_emails.csv') as f:
#     mme = f.read().split()

already_sent = []

already_sent_emails = """""".splitlines()


resend = [

]

resend_emails = [
    'j-redl@online.de',
    'elowe1@zoominternet.net',
    'mamabear7755@yahoo.com',
    'exblueorange2112@yahoo.com',
    'sannephoto@online.de',
]


check_emails = [

]


for i in range(len(df)):

    r = df.loc[i]
    user_id = r['id']



    target_filename = r['target_filename']
    name = r['name']
    email = entry_by_user_id[user_id][0]['email']

    # if email not in mme:
    #     continue

    project_1 = entry_by_user_id[user_id][0]['project_title_one']
    project_2 = entry_by_user_id[user_id][0]['project_title_two']

    subheader = r['subheader']
    stage_text = r['stage_text']
    prize = r['prize']
    ttype = r['type']


    if isinstance(subheader, float):
        subheader = ttype.title()
    data = {
        'email': email,
        'user_id': user_id,
        'target_filename': target_filename,
        'name': name,
        'subheader': subheader,
        'project_1': project_1,
        'project_2': project_2,
        'stage_text': stage_text,
        'prize': prize,
        'type': ttype,
    }
    if user_id not in certs_by_id:
        certs_by_id[user_id] = [ data ]
    else:
        certs_by_id[user_id].append( data )



pprint(certs_by_id)
sys.exit()

count = 0
test_count=1000
for user_id, certs in certs_by_id.items():
    if count >= test_count:
        continue
    email = entry_by_user_id[user_id][0]['email']
    if user_id in already_sent or email in already_sent_emails:
        print('{}: skip already sent {} {}'.format(count,user_id,email))
        continue
    if (len(resend) != 0 or len(resend_emails) != 0) and not (user_id in resend or email in resend_emails):
        print('{}: avoid resend {} {}'.format(count,user_id,email))
        continue
    if len(check_emails)>0:
        if email in check_emails:
            print(f"    '{email}',")
        continue
    send_email(user_id, entry_by_user_id[user_id][0], certs, cert_folder, year, photo_certs_emails )
    count += 1
    print(email)

print(f"{count} emails sent")